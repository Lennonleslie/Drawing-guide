import{_ as d}from"./板件类型-45023cef.js";import{_ as p,M as r,p as h,q as l,R as i,t,N as o,V as n,a1 as e}from"./framework-96b046e1.js";const c={},s=e('<h2 id="空间概念" tabindex="-1"><a class="header-anchor" href="#空间概念" aria-hidden="true">#</a> 空间概念</h2><p>学习此软件，需要有一定的数学三维空间概念基础。</p><h3 id="维度入门d" tabindex="-1"><a class="header-anchor" href="#维度入门d" aria-hidden="true">#</a> 维度入门D</h3><p>XYZ三轴方向。首先看一个图</p><p><img src="http://tva1.sinaimg.cn/large/40a75943gy1h9haey6xtrj20d408ymzh.jpg" alt="../picture/backend-data/01三维示意图.png"></p><p>猴子模型</p><table><thead><tr><th>对应方向</th><th>X轴（红线）</th><th>Y轴（绿线）</th><th>Z轴（蓝线）隐藏</th></tr></thead><tbody><tr><td>正值</td><td>右面（红色耳朵）</td><td>背面（后脑勺）</td><td>上面（头顶）</td></tr><tr><td>负值</td><td>左面（蓝色耳朵）</td><td>正面（鼻子）</td><td>下面（下巴）</td></tr></tbody></table><hr><h4 id="三维属性" tabindex="-1"><a class="header-anchor" href="#三维属性" aria-hidden="true">#</a> 三维属性</h4><p>那么我们需要了解一个物体具备三个空间概念。</p><p>这三个概念都具备三个轴的属性，只是运用的属性不同。</p><ul><li>尺寸 <ul><li>尺寸决定了物体的大小</li></ul></li><li>位置 <ul><li>位置决定了物体的摆放</li></ul></li><li>旋转 <ul><li>旋转决定了物体的朝向</li></ul></li></ul><h3 id="维度进阶-尺寸篇" tabindex="-1"><a class="header-anchor" href="#维度进阶-尺寸篇" aria-hidden="true">#</a> 维度进阶-尺寸篇</h3><p>这里一般设计师不需要深刻记忆，只需要知道有这么一个概念即可，这个是为了后续铺垫的基础知识。</p><p>正常情况下，物体的正面都与我们第一视角相对。</p><blockquote><ul><li><p>X轴一般对应物体的<strong>宽度</strong>，一般参数中是<code>width</code>，简称---<code>W</code></p></li><li><p>Y轴一般对应物体的<strong>深度</strong>，一般参数中是<code>depth</code>，简称---<code>D</code></p></li><li><p>Z轴一般对应物体的<strong>高度</strong>，一般参数中是<code>height</code>，简称---<code>H</code></p></li></ul></blockquote><p>市面常见软件有两种修改方式，一种是基于物体中心，像对应轴的正负方向形变。</p><p>另一种是，基于物体的某个面，向另一个方向形变。本质上没有区别。只是计算方式和坐标方式的不同。</p><h3 id="维度进阶-位置篇" tabindex="-1"><a class="header-anchor" href="#维度进阶-位置篇" aria-hidden="true">#</a> 维度进阶-位置篇</h3><p>这里一般设计师不需要深刻记忆，只需要知道有这么一个概念即可，这个是为了后续铺垫的基础知识。</p><blockquote><ul><li><p>X轴一般对应物体的<strong>左右位置</strong></p></li><li><p>Y轴一般对应物体的<strong>前后位置</strong></p></li><li><p>Z轴一般对应物体的<strong>上下位置</strong></p></li></ul></blockquote><p>位置本身计算并不困难，但是位置计算一般需要叠加尺寸，另外位置在不同软件的相对中心点不同。导致了计算公式的复杂程度也有不同。</p><blockquote><p>中间计算：</p><blockquote><p>一般为物体中心点，为位置的位置坐标，常用在3D软件中，因物体外观不规则，球形、类球形计算具有一定优势。</p><p>例如，一个半径1000㎜的球体，一个位置0的墙面。那么我们要输入1000m的位置坐标值，球体会刚好和墙面接触。</p><p><img src="http://tva1.sinaimg.cn/large/40a75943gy1h9haey6xtrj20d408ymzh.jpg" alt="../picture/backend-data/01三维示意图.png"></p><p>就像这只猴子中心的那个准心一样。</p></blockquote><p>指定点计算（左下后）：</p><blockquote><p>一般为物体的左面下面后面，三面交汇处的点。</p><p>这个视图是柜体的背面，观察下方的准心处。如果柜体面对我们，这个点就位于物体的坐下后。这个一般在矩形物体中，具有得天独厚的计算优势。</p><p><img src="https://tva1.sinaimg.cn/large/40a75943gy1h9hcbd9ndgj20hr0gkjxk.jpg" alt="../picture/backend-data/02原点坐标图.png"></p></blockquote></blockquote><p>位置的计算方式不同不影响逻辑。也只是计算方式的优劣。区别不大。</p><p>但是大多数软件的空间坐标是根据上方猴头图的右上角的坐标一样，Y+方向是在背面（我们所谓的背面）。所以Y轴越大越往后。Y-方向则距离我们更近一些。</p><p>其实这里并没有错误，错误的是一个习惯和显示的问题。因为我们默认习惯于构建的物体像照镜子一样面对我们。所以我们一般会把物体的背面，放在我们第一眼看不到的正面，导致了Y轴正负方向与我们第一时间自以为的方向产生了差异。</p><div class="custom-container danger"><p class="custom-container-title">DANGER</p><p>警告：尺寸值的增加和位置值的增加是完全不同的。一定要区分开！！</p></div><table><thead><tr><th style="text-align:center;">影响</th><th style="text-align:center;">正 方 向 加 大</th><th style="text-align:center;">正 方 向 加 大</th><th style="text-align:center;">负 方 向 减 小</th><th style="text-align:center;">负 方 向 减 小</th></tr></thead><tbody><tr><td style="text-align:center;">轴向</td><td style="text-align:center;">尺寸</td><td style="text-align:center;">位置</td><td style="text-align:center;">尺寸</td><td style="text-align:center;">位置</td></tr><tr><td style="text-align:center;">X方向</td><td style="text-align:center;">宽度变大</td><td style="text-align:center;">物体左移</td><td style="text-align:center;">宽度变小</td><td style="text-align:center;">物体左移</td></tr><tr><td style="text-align:center;">Y方向</td><td style="text-align:center;">深度变大</td><td style="text-align:center;">物体后移</td><td style="text-align:center;">深度变小</td><td style="text-align:center;">物体前移</td></tr><tr><td style="text-align:center;">Z方向</td><td style="text-align:center;">高度变大</td><td style="text-align:center;">物体上移</td><td style="text-align:center;">高度变小</td><td style="text-align:center;">物体下移</td></tr></tbody></table><h3 id="维度进阶-旋转篇" tabindex="-1"><a class="header-anchor" href="#维度进阶-旋转篇" aria-hidden="true">#</a> 维度进阶-旋转篇</h3><p>一般针对不同角度的设计需求。</p><p>此知识点设计几乎用不上，可以直接跳过。</p><blockquote><p><strong>沿<code>X/Y/Z</code>轴旋转123°</strong></p><p>这种表达方式，是常见的标准描述。展开解释，例如，沿着Y轴旋转90度。上图中的猴子就会顺时针旋转90°</p><p>关于旋转的逻辑，首先确认的是，三轴的相对角度绝对是90度的。这也就是我们身处于三维数学世界，无法观测四维的主要原因。我们所在的世界暂时不能找到与这三个轴同时保持90度的第四轴。</p><blockquote><p><strong>世界轴</strong></p><p>世界坐标是这个世界的轴向，一般特指软件页面的轴向。这个是绝对不变的。就像是我们日常生活中无法更改的高度（上下）概念一样。</p><p>因为世界的上下不可颠倒，所以世界前方也避让交叉于世界Z轴。所以前方的作用域只能是一个2维平面的圆。</p><p>而世界轴中，不能区分左右，一切左右的概念都是不同角度方向的前方。</p></blockquote><blockquote><p><strong>个体轴</strong></p><p>物体轴是根据物体本身区分的，个体的上下左右前后。是相对于它自身的。而言，闭上眼睛，不论你旋转的多么晕，你都能根据你自己区分出来你自己的上下左右前后。</p><p>但是个体轴中，存在着难以共同的特点。例如，二人相遇，错开让路。你说的左是他的右。所以会有一些</p><p>’你往左，我往右。‘的尴尬对话</p><p>为了避免这种情况，北方地区多会以世界坐标，东南西北为方向参照物。我往东，你往西。反而可以避免这种情况。</p></blockquote><p>所以，根据上述观念的描述，软件也类似于这种情况。他们尽可能多的使用世界轴，但是也为了方便大众人群（区分东南西北存在难度），采用了两种轴的结合使用方式。</p><p>首先是上下观念，因为上下这个观点在地球范围内，基本上没有异议。所以个体轴一般的Z轴和世界轴通用。</p><p>其次是前后概念，前后概念因为你只要面对哪边，哪边就为前面，并且它永远和Z轴交叉呈90度。如果平行与Z轴，则这个物体Z轴和Y轴重叠使用。</p><p>最后就是左右概念，这个根本用不上世界坐标，它属于目标对象自己的坐标。</p><p>这个旋转轴就像是一个在深海潜水。你唯一可以参照世界的就是上下，其次根据上下我们判断前方。但是我们侧着游泳，或者斜躺，亦或者其他形态。</p><p>我们的左右相对我们是永恒不变的。</p><p><strong>总结</strong></p><ol><li>轴只有三个且相互之间绝对垂直</li><li>尺寸和位置和旋转是独立的。</li><li>逻辑上的认知误差是行业误差。不是逻辑错误。、</li></ol></blockquote><h4 id="板件旋转" tabindex="-1"><a class="header-anchor" href="#板件旋转" aria-hidden="true">#</a> 板件旋转</h4><p>板件比较基础。但是一般具备三种摆放方式</p><p><img src="'+d+'" alt=""></p><h2 id="参数类型" tabindex="-1"><a class="header-anchor" href="#参数类型" aria-hidden="true">#</a> 参数类型</h2><p>此类目，设计师有个初步了解就行。方便知道后台可以做什么。能做什么。提升与后端人员的有效沟通。</p>',37),u=e(`<p>板件的规则默认板件都是横板，其他板件都是根据横板旋转而来</p><table><thead><tr><th>板件名</th><th>X轴旋转</th><th>Y轴旋转</th><th>Z轴旋转</th></tr></thead><tbody><tr><td>横板</td><td>0</td><td>0</td><td>0</td></tr><tr><td>竖板</td><td>0</td><td>90</td><td>0</td></tr><tr><td>面/背板</td><td>90</td><td>-90</td><td>0</td></tr></tbody></table><hr><h3 id="数值类-浮点数-整数" tabindex="-1"><a class="header-anchor" href="#数值类-浮点数-整数" aria-hidden="true">#</a> 数值类（浮点数&amp;整数）</h3><h4 id="浮点数" tabindex="-1"><a class="header-anchor" href="#浮点数" aria-hidden="true">#</a> 浮点数</h4><p>浮点数是数学专用词汇，但是简单理解就是具备小数能力的数值都叫浮点数。</p><h4 id="整数" tabindex="-1"><a class="header-anchor" href="#整数" aria-hidden="true">#</a> 整数</h4><p>整数与浮点数的区别很小，整数不支持小数点，必须为小数点之前的数值。</p><hr><h3 id="数值类——可选" tabindex="-1"><a class="header-anchor" href="#数值类——可选" aria-hidden="true">#</a> 数值类——可选</h3><p>制作一个可选项，可以有单项或者多项选择。</p><blockquote><p>一般用于一些内部样式的选择。</p><blockquote><p>什么是内部样式？</p><p>内部样式是这个模型本身自带的一些功能，例如抽屉选择抽底的工艺</p><blockquote><ul><li><p>[x] 薄抽底</p></li><li><p>[ ] 厚抽底</p></li></ul></blockquote></blockquote></blockquote><hr><blockquote><p>也可以用于一些快速选择。</p><p>比如说结构变量</p><blockquote><p>结构变量——顶部结构</p><p>一般选择侧夹顶，或者顶盖侧。（根据个人|企业的需求有其他多选项目）</p><blockquote><ul><li><p>[x] 侧夹顶</p></li><li><p>[ ] 顶盖左</p></li><li><p>[ ] 顶盖右</p></li><li><p>[ ] 顶盖侧</p></li></ul></blockquote></blockquote></blockquote><p>但是这种样式必选其一。</p><hr><h3 id="数值类——区间" tabindex="-1"><a class="header-anchor" href="#数值类——区间" aria-hidden="true">#</a> 数值类——区间</h3><p>区间的作用是设定一个上限和一个下限做出一个范围。常用的尺寸，或者一些结构数值类，一般使用此项的较多。</p><blockquote><p>例如宽度选项。</p><p>在鼠标移入宽度输入栏时，会显示一个<code>500~2100</code>的选项。</p><p>此处的<code>500</code>为数值最小值，<code>2100</code>为最大值。</p><p>输入的值只能在两者之间，或者等于最大值、最小值。</p></blockquote><hr><h3 id="数值类——复合公式-公式" tabindex="-1"><a class="header-anchor" href="#数值类——复合公式-公式" aria-hidden="true">#</a> 数值类——复合公式&amp;公式</h3><p>公式的作用是自动计算一个值。</p><h4 id="复合公式" tabindex="-1"><a class="header-anchor" href="#复合公式" aria-hidden="true">#</a> 复合公式</h4><p>复合公式是区间+公式的组合体参数。部分软件有不同的称谓。一般使用在柜体自动分布的值，使用率较高。</p><blockquote><p>一般应用场景.</p><blockquote><p>例如裤管抽</p><p>裤管的数量一般会根据抽盒内空的宽度决定数量。</p><p>但部分特殊需求，会指定数量的多少。于是在自动计算的情况下。给设计师一个主动修改的选项。</p><p>可以直接输入数值，来替代自动计算的值。</p></blockquote></blockquote><h4 id="公式" tabindex="-1"><a class="header-anchor" href="#公式" aria-hidden="true">#</a> 公式</h4><p>此数据为只读数据，为必然自动计算项目。使用频率较低</p><blockquote><p>例如酒格的特点，酒格的板件交叉必然为90°</p><p>所以酒格的长和宽的比例是固定的公式，非常不建议人为修改。为了避免。大多数的酒格的宽度或者高度二者之一。为公式选项。</p></blockquote><hr><h3 id="数值类——固定值" tabindex="-1"><a class="header-anchor" href="#数值类——固定值" aria-hidden="true">#</a> 数值类——固定值</h3><p>此数据为只读数据，使用频率较低</p><blockquote><p>例如，某个五金的宽度只有固定的值可以选择时。才会使用固定值。</p></blockquote><hr><h3 id="字符串" tabindex="-1"><a class="header-anchor" href="#字符串" aria-hidden="true">#</a> 字符串</h3><p>此项数值类型应用范围较窄，几乎没有应用。</p><p>什么是字符串，你肉眼可见的文字信息皆为字符串。例如这一行文字。</p><p>字符串支持了除了<strong>区间</strong>以外的所有数值类型的参数类型。</p><p>可以参考参数类型文章直接阅读。但是字符串不具备运算能力。</p><blockquote><p>一般数值类型的可以直接运算，比如说面积计算。</p><blockquote><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>W*H/10000000=X㎡
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>W：width（宽度）H：height（高度）X：结果数值。</p></blockquote><p>但是字符串类型的无法计算。</p><p>书和柜子加在一起，我们或许能想到书柜。但是在数学上是不可行的。</p></blockquote><p><em><strong>所以正常情况下。不推荐使用字符串数据</strong></em></p><blockquote><p>一般字符串数据可以被可选项替代。</p></blockquote><h3 id="布尔值" tabindex="-1"><a class="header-anchor" href="#布尔值" aria-hidden="true">#</a> 布尔值</h3><p>布尔值专业名称叫Boolean，一般用于，Y/N？使用频率不高。</p><p>布尔值在其他平台或者模型上，或许使用频率尚可。严格遵循了答案的唯一性。<strong>是</strong>或者<strong>否</strong>。</p><p>但是在实际生产环境中，我们的选项或许是不断增加的。单项选择大部分无法满足需求。</p><blockquote><p>应用场景</p><blockquote><p>比如说设定一个柜体是否顶盖侧。</p><ul><li>[x] 顶盖侧</li></ul><p>选择了就顶盖则，否则只能侧夹顶。</p></blockquote><p>应该发现，这个信息在数值类——可选的页面已经说过。所以这个功能是有些重复的。功能较为单一。</p></blockquote><p>我们不推荐使用Boolean的原因还有可维护性。这个公式运用之后，后续如果新增选项，维护的成本是可选项的数倍之多。所以不推荐使用。</p><p>但也不是绝对不行。在一些确定几乎不升级，或者说只能选择YES|NO的情况下，可以使用Boolean。也不考虑所谓的维护性。</p><p>而且在模型组合中，具有很强的局限性。应用场景不得不缩小。</p><p>此项数据有两个子分类</p><h4 id="布尔值——无限制" tabindex="-1"><a class="header-anchor" href="#布尔值——无限制" aria-hidden="true">#</a> 布尔值——无限制</h4><p>无限制则就是可以选择Y|N。</p><h4 id="布尔值——固定值" tabindex="-1"><a class="header-anchor" href="#布尔值——固定值" aria-hidden="true">#</a> 布尔值——固定值</h4><p>固定值不可更改，默认是什么就是什么。所以此项几乎没有使用场景。</p><hr><h3 id="多布尔值" tabindex="-1"><a class="header-anchor" href="#多布尔值" aria-hidden="true">#</a> 多布尔值</h3><p>与布尔值具有相同的特征，但多了一个特性。</p><p>多布尔值其实是多个布尔值的集合</p><blockquote><p>应用场景</p><blockquote><p>设定一个柜体的<code>底托侧</code>和<code>顶盖侧</code>。</p><ul><li>[x] 顶盖侧</li><li>[x] 底托侧</li></ul><p>我们可以同时选择两个工艺。</p></blockquote></blockquote><p>优点明显大于可选，但是维护成本更高了。所以这里依然没有采用。</p><h3 id="材质-样式" tabindex="-1"><a class="header-anchor" href="#材质-样式" aria-hidden="true">#</a> 材质&amp;样式</h3><p>材质是贴图特有的参数类型。服务于贴图的切换。</p><p>样式是模型本身可以替换的选项。方便替换某个组件为其他同类型的组件。</p><h3 id="材质-样式——无限制" tabindex="-1"><a class="header-anchor" href="#材质-样式——无限制" aria-hidden="true">#</a> 材质&amp;样式——无限制</h3><p>可以切换为材质库里所有的可见材质。</p><p>样式则为同类别的模型进行替换</p><h3 id="材质-样式——可选" tabindex="-1"><a class="header-anchor" href="#材质-样式——可选" aria-hidden="true">#</a> 材质&amp;样式——可选</h3><p>可以切换为<strong>材质&amp;样式包</strong>里面指定的材质。材质&amp;样式包需要提前制作。</p><p>或者以公式来写。支持多种材质&amp;样式包以供选择。</p><h3 id="材质-样式——复合公式-公式" tabindex="-1"><a class="header-anchor" href="#材质-样式——复合公式-公式" aria-hidden="true">#</a> 材质&amp;样式——复合公式&amp;公式</h3><p>根据公式可以选择材质&amp;样式包或者引用的其他材质&amp;样式参数。</p><p>复合公式在公式的基础上添加了可选和无限制的功能。</p><h3 id="材质-样式——固定值" tabindex="-1"><a class="header-anchor" href="#材质-样式——固定值" aria-hidden="true">#</a> 材质&amp;样式——固定值</h3><p>固定材质&amp;样式，不可切换。</p><h3 id="轮廓" tabindex="-1"><a class="header-anchor" href="#轮廓" aria-hidden="true">#</a> 轮廓</h3><p>一般为某个线条的选择。但是轮廓有个先天缺陷。轮廓可编辑的系数较小。一般为固定样式。例如铝型材。</p><p>但是因为效果图之类的因素，轮廓不存在材质，没有光源及中间部分的造型等。现在定制化的铝型材等线条，大多也会存在一些造型，不能一条拉通。</p><p>所以目前使用场景存在争议。</p><h3 id="轮廓——无限制" tabindex="-1"><a class="header-anchor" href="#轮廓——无限制" aria-hidden="true">#</a> 轮廓——无限制</h3><p>可以切换为轮廓库里所有的可见轮廓。</p><h3 id="轮廓——可选" tabindex="-1"><a class="header-anchor" href="#轮廓——可选" aria-hidden="true">#</a> 轮廓——可选</h3><p>可以切换为<strong>轮廓包</strong>里面指定的材质。轮廓包需要提前制作。</p><p>或者以公式来写。支持多种轮廓包以供选择。</p><h3 id="轮廓——固定值" tabindex="-1"><a class="header-anchor" href="#轮廓——固定值" aria-hidden="true">#</a> 轮廓——固定值</h3><p>固定轮廓，不可切换。</p>`,85);function b(g,x){const a=r("RouterLink");return h(),l("div",null,[s,i("p",null,[t("如果没有结构基础，那么阅读以下文章或许存在困难，可以先阅读一下"),o(a,{to:"/start/%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90.html"},{default:n(()=>[t("结构解析")]),_:1})]),u])}const m=p(c,[["render",b],["__file","数学逻辑.html.vue"]]);export{m as default};
